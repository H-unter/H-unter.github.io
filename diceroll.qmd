---
title: "Dice Roll Utility"
format:
  html:
    theme: cosmo
---

```{ojs}
//| echo: false

// Import required libraries
Plot = import("https://esm.sh/@observablehq/plot@0.6")
d3 = import("https://esm.sh/d3@7")
```

## Character Stats

```{ojs}
//| echo: false

// Create individual stat inputs in a compact grid
statsInputs = html`
<div class="row g-2">
  <div class="col-md-4">
    ${Inputs.range([0, 6], {value: 3, step: 1, label: "Proficiency Bonus"})}
  </div>
  <div class="col-md-4">
    ${Inputs.range([-5, 10], {value: 1, step: 1, label: "STR"})}
  </div>
  <div class="col-md-4">
    ${Inputs.range([-5, 10], {value: 2, step: 1, label: "DEX"})}
  </div>
  <div class="col-md-4">
    ${Inputs.range([-5, 10], {value: 2, step: 1, label: "CON"})}
  </div>
  <div class="col-md-4">
    ${Inputs.range([-5, 10], {value: 0, step: 1, label: "INT"})}
  </div>
  <div class="col-md-4">
    ${Inputs.range([-5, 10], {value: 4, step: 1, label: "WIS"})}
  </div>
  <div class="col-md-4">
    ${Inputs.range([-5, 10], {value: -1, step: 1, label: "CHA"})}
  </div>
</div>
`

viewof PROFICIENCY_BONUS = Inputs.range([0, 6], {value: 3, step: 1, label: "Proficiency Bonus"})
viewof STR_MOD = Inputs.range([-5, 10], {value: 1, step: 1, label: "STR"})
viewof DEX_MOD = Inputs.range([-5, 10], {value: 2, step: 1, label: "DEX"})
viewof CON_MOD = Inputs.range([-5, 10], {value: 2, step: 1, label: "CON"})
viewof INT_MOD = Inputs.range([-5, 10], {value: 0, step: 1, label: "INT"})
viewof WIS_MOD = Inputs.range([-5, 10], {value: 4, step: 1, label: "WIS"})
viewof CHA_MOD = Inputs.range([-5, 10], {value: -1, step: 1, label: "CHA"})
```

```{ojs}
//| echo: false

// Combine stats into object
characterStats = ({
  PROFICIENCY_BONUS,
  STR_MOD,
  DEX_MOD,
  CON_MOD,
  INT_MOD,
  WIS_MOD,
  CHA_MOD
})
```

```{ojs}
//| echo: false

// Initial spells configuration
initialSpells = ({
  Fireball: {
    level: 3,
    to_hit: "1d20 + PROFICIENCY_BONUS + WIS_MOD",
    damage: "8d6"
  },
  "Cure Wounds": {
    level: 1,
    to_hit: "None",
    damage: "1d8 + WIS_MOD"
  },
  Greataxe: {
    level: 0,
    to_hit: "1d20 + PROFICIENCY_BONUS + STR_MOD",
    damage: "1d12 + STR_MOD"
  }
})

viewof spellsConfigInput = Inputs.input(initialSpells)
spellsConfig = spellsConfigInput
```

::: {.callout-note collapse="true"}
## ‚öôÔ∏è Import / Export Config

```{ojs}
//| echo: false

autoGeneratedConfig = JSON.stringify({
  character_info: characterStats,
  spells: spellsConfig
}, null, 2)

html`<textarea rows="12" style="width: 100%; font-family: monospace; padding: 10px; font-size: 0.85em;">${autoGeneratedConfig}</textarea>`
```
:::

```{ojs}
//| echo: false

// Dice rolling functions
function parseDiceNotation(notation, stats) {
  if (!notation || notation === "None") return null;
  
  let formula = notation.trim();
  Object.keys(stats).forEach(key => {
    const regex = new RegExp(key, 'g');
    formula = formula.replace(regex, stats[key]);
  });
  
  const parts = formula.split(/([+-])/);
  let diceTerms = [];
  let constantBonus = 0;
  
  let currentSign = 1;
  for (let part of parts) {
    part = part.trim();
    if (part === '+') {
      currentSign = 1;
    } else if (part === '-') {
      currentSign = -1;
    } else if (part.includes('d')) {
      const [count, sides] = part.split('d').map(x => parseInt(x));
      if (!isNaN(count) && !isNaN(sides)) {
        diceTerms.push({ count, sides, sign: currentSign });
      }
    } else if (part && !isNaN(part)) {
      constantBonus += currentSign * parseInt(part);
    }
  }
  
  return { diceTerms, constantBonus, original: notation, resolved: formula };
}

function calculateDistribution(diceTerms, constantBonus) {
  if (diceTerms.length === 0) {
    return new Map([[constantBonus, 1.0]]);
  }
  
  let distribution = singleDieDistribution(diceTerms[0].count, diceTerms[0].sides, diceTerms[0].sign);
  
  for (let i = 1; i < diceTerms.length; i++) {
    const nextDist = singleDieDistribution(diceTerms[i].count, diceTerms[i].sides, diceTerms[i].sign);
    distribution = convolve(distribution, nextDist);
  }
  
  if (constantBonus !== 0) {
    const shifted = new Map();
    for (let [outcome, prob] of distribution) {
      shifted.set(outcome + constantBonus, prob);
    }
    distribution = shifted;
  }
  
  return distribution;
}

function singleDieDistribution(count, sides, sign = 1) {
  if (count === 0) return new Map([[0, 1.0]]);
  
  let dist = new Map();
  for (let i = 1; i <= sides; i++) {
    dist.set(sign * i, 1.0 / sides);
  }
  
  for (let n = 1; n < count; n++) {
    const oneDie = new Map();
    for (let i = 1; i <= sides; i++) {
      oneDie.set(sign * i, 1.0 / sides);
    }
    dist = convolve(dist, oneDie);
  }
  
  return dist;
}

function convolve(dist1, dist2) {
  const result = new Map();
  
  for (let [outcome1, prob1] of dist1) {
    for (let [outcome2, prob2] of dist2) {
      const sum = outcome1 + outcome2;
      const prob = prob1 * prob2;
      result.set(sum, (result.get(sum) || 0) + prob);
    }
  }
  
  return result;
}

function rollDice(diceTerms, constantBonus) {
  let total = constantBonus;
  
  for (let term of diceTerms) {
    for (let i = 0; i < term.count; i++) {
      const roll = Math.floor(Math.random() * term.sides) + 1;
      total += term.sign * roll;
    }
  }
  
  return total;
}

function createPlot(data, rollResult) {
  const outcomes = data.map(d => d.outcome);
  const probs = data.map(d => d.probability);
  
  return Plot.plot({
    width: 400,
    height: 200,
    marginBottom: 40,
    marginLeft: 40,
    marginRight: 20,
    x: { 
      label: "Outcome",
      labelAnchor: "center"
    },
    y: { 
      label: "Probability",
      percent: true,
      labelAnchor: "center"
    },
    marks: [
      Plot.barY(data, {
        x: "outcome",
        y: "probability",
        fill: d => d.outcome === rollResult ? "#dc3545" : "#6c757d",
        opacity: d => d.outcome === rollResult ? 1 : 0.5
      }),
      Plot.ruleX([rollResult], {
        stroke: "#dc3545",
        strokeWidth: 2
      })
    ]
  });
}
```

## Spells & Actions

```{ojs}
//| echo: false

spellCards = {
  const spellEntries = Object.entries(spellsConfig);
  
  const cards = spellEntries.map(([name, spell]) => {
    const cardId = name.replace(/\s+/g, '-');
    
    // Create containers
    const card = html`<div class="col-lg-6 mb-4"></div>`;
    
    const toHitInput = Inputs.text({
      value: spell.to_hit,
      placeholder: "e.g., 1d20 + PROFICIENCY_BONUS + STR_MOD"
    });
    
    const damageInput = Inputs.text({
      value: spell.damage,
      placeholder: "e.g., 2d6 + STR_MOD"
    });
    
    // Update config on input change
    toHitInput.addEventListener('input', (e) => {
      const newSpells = {...spellsConfig};
      newSpells[name].to_hit = e.target.value;
      spellsConfigInput.value = newSpells;
      spellsConfigInput.dispatchEvent(new Event("input", {bubbles: true}));
    });
    
    damageInput.addEventListener('input', (e) => {
      const newSpells = {...spellsConfig};
      newSpells[name].damage = e.target.value;
      spellsConfigInput.value = newSpells;
      spellsConfigInput.dispatchEvent(new Event("input", {bubbles: true}));
    });
    
    // Result containers
    const toHitResultDiv = html`<div class="mt-2"></div>`;
    const damageResultDiv = html`<div class="mt-2"></div>`;
    
    // Roll buttons
    const toHitButton = html`<button class="btn btn-primary btn-sm mt-2 w-100">üé≤ Roll To Hit</button>`;
    const damageButton = html`<button class="btn btn-danger btn-sm mt-2 w-100">üé≤ Roll Damage</button>`;
    
    toHitButton.onclick = () => {
      const parsed = parseDiceNotation(spell.to_hit, characterStats);
      if (!parsed) {
        toHitResultDiv.innerHTML = '<div class="alert alert-warning p-2">Invalid formula!</div>';
        return;
      }
      
      const result = rollDice(parsed.diceTerms, parsed.constantBonus);
      const dist = calculateDistribution(parsed.diceTerms, parsed.constantBonus);
      const data = Array.from(dist).map(([outcome, prob]) => ({outcome, probability: prob})).sort((a, b) => a.outcome - b.outcome);
      
      const cumulativeProb = data.reduce((acc, d) => d.outcome < result ? acc + d.probability : acc, 0);
      const percentile = (cumulativeProb * 100).toFixed(0);
      
      toHitResultDiv.innerHTML = '';
      toHitResultDiv.appendChild(html`
        <div class="result-box p-2 mt-2 border rounded bg-light">
          <div class="text-center mb-2">
            <span class="fs-3 fw-bold text-primary">${result}</span>
            <span class="ms-2 badge bg-info">${percentile}%ile</span>
          </div>
          <div class="plot-container">
            ${createPlot(data, result)}
          </div>
        </div>
      `);
    };
    
    damageButton.onclick = () => {
      const parsed = parseDiceNotation(spell.damage, characterStats);
      if (!parsed) {
        damageResultDiv.innerHTML = '<div class="alert alert-warning p-2">Invalid formula!</div>';
        return;
      }
      
      const result = rollDice(parsed.diceTerms, parsed.constantBonus);
      const dist = calculateDistribution(parsed.diceTerms, parsed.constantBonus);
      const data = Array.from(dist).map(([outcome, prob]) => ({outcome, probability: prob})).sort((a, b) => a.outcome - b.outcome);
      
      const cumulativeProb = data.reduce((acc, d) => d.outcome < result ? acc + d.probability : acc, 0);
      const percentile = (cumulativeProb * 100).toFixed(0);
      
      damageResultDiv.innerHTML = '';
      damageResultDiv.appendChild(html`
        <div class="result-box p-2 mt-2 border rounded bg-light">
          <div class="text-center mb-2">
            <span class="fs-3 fw-bold text-danger">${result}</span>
            <span class="ms-2 badge bg-info">${percentile}%ile</span>
          </div>
          <div class="plot-container">
            ${createPlot(data, result)}
          </div>
        </div>
      `);
    };
    
    // Build card
    const toHitSection = spell.to_hit !== "None" ? html`
      <div class="mb-3 pb-3 border-bottom">
        <label class="small text-muted fw-bold mb-1">TO HIT</label>
        ${toHitInput}
        ${toHitButton}
        ${toHitResultDiv}
      </div>
    ` : '';
    
    card.appendChild(html`
      <div class="card shadow-sm h-100">
        <div class="card-header d-flex justify-content-between align-items-center">
          <strong>${name}</strong>
          <span class="badge bg-primary">Lvl ${spell.level}</span>
        </div>
        <div class="card-body">
          ${toHitSection}
          <div>
            <label class="small text-muted fw-bold mb-1">DAMAGE</label>
            ${damageInput}
            ${damageButton}
            ${damageResultDiv}
          </div>
        </div>
      </div>
    `);
    
    return card;
  });
  
  return html`
<style>
  .card { transition: all 0.2s; }
  .card:hover { box-shadow: 0 4px 12px rgba(0,0,0,0.15) !important; }
  .result-box {
    animation: slideIn 0.3s ease-out;
    background: linear-gradient(to bottom, #f8f9fa, #ffffff) !important;
  }
  @keyframes slideIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
  }
  .plot-container { 
    display: flex; 
    justify-content: center; 
  }
</style>

<div class="row">
  ${cards}
</div>
`;
}
```

```{ojs}
//| echo: false
spellCards
```
