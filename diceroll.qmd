---
title: "Dice Roll Utility"
format:
  html:
    theme: cosmo
---

```{ojs}
//| echo: false

// Import required libraries
Plot = import("https://esm.sh/@observablehq/plot@0.6")
d3 = import("https://esm.sh/d3@7")
```

## Character Stats

```{ojs}
//| echo: false

// Create individual stat inputs
viewof PROFICIENCY_BONUS = Inputs.range([0, 6], {value: 3, step: 1, label: "Proficiency Bonus"})
viewof STR_MOD = Inputs.range([-5, 10], {value: 1, step: 1, label: "STR"})
viewof DEX_MOD = Inputs.range([-5, 10], {value: 2, step: 1, label: "DEX"})
viewof CON_MOD = Inputs.range([-5, 10], {value: 2, step: 1, label: "CON"})
viewof INT_MOD = Inputs.range([-5, 10], {value: 0, step: 1, label: "INT"})
viewof WIS_MOD = Inputs.range([-5, 10], {value: 4, step: 1, label: "WIS"})
viewof CHA_MOD = Inputs.range([-5, 10], {value: -1, step: 1, label: "CHA"})
```

```{ojs}
//| echo: false

// Combine stats into object
characterStats = ({
  PROFICIENCY_BONUS,
  STR_MOD,
  DEX_MOD,
  CON_MOD,
  INT_MOD,
  WIS_MOD,
  CHA_MOD
})
```

```{ojs}
//| echo: false

// Initial spells configuration
initialSpells = ({
  Fireball: {
    level: 3,
    to_hit: "1d20 + PROFICIENCY_BONUS + WIS_MOD",
    damage: "8d6"
  },
  "Cure Wounds": {
    level: 1,
    to_hit: "None",
    damage: "1d8 + WIS_MOD"
  },
  Greataxe: {
    level: 0,
    to_hit: "1d20 + PROFICIENCY_BONUS + STR_MOD",
    damage: "1d12 + STR_MOD"
  },
  "Sacred Flame": {
    level: 0,
    to_hit: "None",
    damage: "1d8"
  }
})

viewof spellsConfigInput = Inputs.input(initialSpells)
spellsConfig = spellsConfigInput
```

::: {.callout-note collapse="true"}
## ‚öôÔ∏è Import / Export Config

```{ojs}
//| echo: false

autoGeneratedConfig = JSON.stringify({
  character_info: characterStats,
  spells: spellsConfig
}, null, 2)

html`<textarea rows="12" style="width: 100%; font-family: monospace; padding: 10px; font-size: 0.85em;">${autoGeneratedConfig}</textarea>`
```
:::

```{ojs}
//| echo: false

// Dice rolling functions
function parseDiceNotation(notation, stats) {
  if (!notation || notation === "None") return null;
  
  let formula = notation.trim();
  Object.keys(stats).forEach(key => {
    const regex = new RegExp(key, 'g');
    formula = formula.replace(regex, stats[key]);
  });
  
  const parts = formula.split(/([+-])/);
  let diceTerms = [];
  let constantBonus = 0;
  
  let currentSign = 1;
  for (let part of parts) {
    part = part.trim();
    if (part === '+') {
      currentSign = 1;
    } else if (part === '-') {
      currentSign = -1;
    } else if (part.includes('d')) {
      const [count, sides] = part.split('d').map(x => parseInt(x));
      if (!isNaN(count) && !isNaN(sides)) {
        diceTerms.push({ count, sides, sign: currentSign });
      }
    } else if (part && !isNaN(part)) {
      constantBonus += currentSign * parseInt(part);
    }
  }
  
  return { diceTerms, constantBonus, original: notation, resolved: formula };
}

function resolveFormula(notation, stats) {
  if (!notation || notation === "None") return "None";
  
  let formula = notation.trim();
  Object.keys(stats).forEach(key => {
    const regex = new RegExp(key, 'g');
    formula = formula.replace(regex, stats[key]);
  });
  
  return formula;
}

function calculateDistribution(diceTerms, constantBonus) {
  if (diceTerms.length === 0) {
    return new Map([[constantBonus, 1.0]]);
  }
  
  let distribution = singleDieDistribution(diceTerms[0].count, diceTerms[0].sides, diceTerms[0].sign);
  
  for (let i = 1; i < diceTerms.length; i++) {
    const nextDist = singleDieDistribution(diceTerms[i].count, diceTerms[i].sides, diceTerms[i].sign);
    distribution = convolve(distribution, nextDist);
  }
  
  if (constantBonus !== 0) {
    const shifted = new Map();
    for (let [outcome, prob] of distribution) {
      shifted.set(outcome + constantBonus, prob);
    }
    distribution = shifted;
  }
  
  return distribution;
}

function singleDieDistribution(count, sides, sign = 1) {
  if (count === 0) return new Map([[0, 1.0]]);
  
  let dist = new Map();
  for (let i = 1; i <= sides; i++) {
    dist.set(sign * i, 1.0 / sides);
  }
  
  for (let n = 1; n < count; n++) {
    const oneDie = new Map();
    for (let i = 1; i <= sides; i++) {
      oneDie.set(sign * i, 1.0 / sides);
    }
    dist = convolve(dist, oneDie);
  }
  
  return dist;
}

function convolve(dist1, dist2) {
  const result = new Map();
  
  for (let [outcome1, prob1] of dist1) {
    for (let [outcome2, prob2] of dist2) {
      const sum = outcome1 + outcome2;
      const prob = prob1 * prob2;
      result.set(sum, (result.get(sum) || 0) + prob);
    }
  }
  
  return result;
}

function rollDice(diceTerms, constantBonus) {
  let total = constantBonus;
  
  for (let term of diceTerms) {
    for (let i = 0; i < term.count; i++) {
      const roll = Math.floor(Math.random() * term.sides) + 1;
      total += term.sign * roll;
    }
  }
  
  return total;
}

function createPlot(data, rollResult, width = 450) {
  return Plot.plot({
    width: width,
    height: 250,
    marginBottom: 40,
    marginLeft: 50,
    marginRight: 20,
    marginTop: 20,
    x: { 
      label: "Outcome",
      labelAnchor: "center",
      grid: true
    },
    y: { 
      label: "Probability",
      percent: true,
      labelAnchor: "center",
      grid: true
    },
    marks: [
      Plot.barY(data, {
        x: "outcome",
        y: "probability",
        fill: d => (rollResult !== null && d.outcome === rollResult) ? "#dc3545" : "#6c757d",
        opacity: d => (rollResult !== null && d.outcome === rollResult) ? 1 : 0.5
      }),
      rollResult !== null ? Plot.ruleX([rollResult], {
        stroke: "#dc3545",
        strokeWidth: 2,
        strokeDasharray: "4"
      }) : null
    ].filter(x => x !== null)
  });
}
```

## Select Spell

```{ojs}
//| echo: false

viewof selectedSpellName = Inputs.select(
  Object.keys(spellsConfig),
  {label: "Choose a spell or action:", value: Object.keys(spellsConfig)[0]}
)
```

```{ojs}
//| echo: false

spellCard = {
  const spell = spellsConfig[selectedSpellName];
  if (!spell) return html`<div>No spell selected</div>`;
  
  // Create main container
  const container = html`<div style="max-width: 1400px; margin: 0 auto;"></div>`;
  
  // Create the card element
  const card = html`
    <div class="card shadow-lg border-0">
      <div class="card-header bg-gradient text-white d-flex justify-content-between align-items-center" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
        <h4 class="mb-0">${selectedSpellName}</h4>
        <span class="badge bg-light text-dark fs-6">Level ${spell.level}</span>
      </div>
      <div class="card-body p-4">
        <div style="display: flex; gap: 30px; flex-wrap: wrap;">
        </div>
      </div>
    </div>
  `;
  
  const flexContainer = card.querySelector('div[style*="display: flex"]');
  
  // Create To Hit section
  if (spell.to_hit !== "None") {
    const toHitSection = html`
      <div style="flex: 1; min-width: 400px; background: #f8f9fa; padding: 20px; border-radius: 8px;">
        <h5 class="text-primary mb-3">‚öîÔ∏è To Hit</h5>
      </div>
    `;
    
    const toHitInput = Inputs.text({
      value: spell.to_hit,
      placeholder: "e.g., 1d20 + PROFICIENCY_BONUS + STR_MOD"
    });
    
    const toHitResolvedDisplay = html`<div class="small text-muted mt-1 mb-2">
      <strong>= ${resolveFormula(spell.to_hit, characterStats)}</strong>
    </div>`;
    
    toHitInput.addEventListener('input', (e) => {
      const newSpells = {...spellsConfig};
      newSpells[selectedSpellName].to_hit = e.target.value;
      spellsConfigInput.value = newSpells;
      spellsConfigInput.dispatchEvent(new Event("input", {bubbles: true}));
      toHitResolvedDisplay.innerHTML = `<strong>= ${resolveFormula(e.target.value, characterStats)}</strong>`;
    });
    
    const toHitPlotDiv = html`<div style="margin: 15px 0;"></div>`;
    const toHitResultDiv = html`<div></div>`;
    const toHitButton = html`<button class="btn btn-primary w-100 btn-lg mt-2">üé≤ Roll To Hit</button>`;
    
    // Render initial plot
    const toHitParsed = parseDiceNotation(spell.to_hit, characterStats);
    if (toHitParsed) {
      const dist = calculateDistribution(toHitParsed.diceTerms, toHitParsed.constantBonus);
      const data = Array.from(dist).map(([outcome, prob]) => ({outcome, probability: prob})).sort((a, b) => a.outcome - b.outcome);
      toHitPlotDiv.appendChild(createPlot(data, null, 450));
    }
    
    toHitButton.onclick = () => {
      const parsed = parseDiceNotation(spell.to_hit, characterStats);
      if (!parsed) {
        toHitResultDiv.innerHTML = '<div class="alert alert-warning mt-2">Invalid formula!</div>';
        return;
      }
      
      const result = rollDice(parsed.diceTerms, parsed.constantBonus);
      const dist = calculateDistribution(parsed.diceTerms, parsed.constantBonus);
      const data = Array.from(dist).map(([outcome, prob]) => ({outcome, probability: prob})).sort((a, b) => a.outcome - b.outcome);
      
      const cumulativeProb = data.reduce((acc, d) => d.outcome < result ? acc + d.probability : acc, 0);
      const percentile = (cumulativeProb * 100).toFixed(0);
      
      toHitResultDiv.innerHTML = '';
      toHitResultDiv.appendChild(html`
        <div class="result-box p-3 mt-3 border rounded text-center" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
          <div class="display-4 fw-bold">${result}</div>
          <div class="mt-2">
            <span class="badge bg-light text-dark fs-6">${percentile}th percentile</span>
          </div>
        </div>
      `);
      
      toHitPlotDiv.innerHTML = '';
      toHitPlotDiv.appendChild(createPlot(data, result, 450));
    };
    
    toHitSection.appendChild(html`<div><label class="small text-muted fw-bold mb-1">Formula</label></div>`);
    toHitSection.appendChild(toHitInput);
    toHitSection.appendChild(toHitResolvedDisplay);
    toHitSection.appendChild(toHitPlotDiv);
    toHitSection.appendChild(toHitButton);
    toHitSection.appendChild(toHitResultDiv);
    
    flexContainer.appendChild(toHitSection);
  }
  
  // Create Damage section
  const damageSection = html`
    <div style="flex: 1; min-width: 400px; background: #f8f9fa; padding: 20px; border-radius: 8px;">
      <h5 class="text-danger mb-3">üí• Damage</h5>
    </div>
  `;
  
  const damageInput = Inputs.text({
    value: spell.damage,
    placeholder: "e.g., 2d6 + STR_MOD"
  });
  
  const damageResolvedDisplay = html`<div class="small text-muted mt-1 mb-2">
    <strong>= ${resolveFormula(spell.damage, characterStats)}</strong>
  </div>`;
  
  damageInput.addEventListener('input', (e) => {
    const newSpells = {...spellsConfig};
    newSpells[selectedSpellName].damage = e.target.value;
    spellsConfigInput.value = newSpells;
    spellsConfigInput.dispatchEvent(new Event("input", {bubbles: true}));
    damageResolvedDisplay.innerHTML = `<strong>= ${resolveFormula(e.target.value, characterStats)}</strong>`;
  });
  
  const damagePlotDiv = html`<div style="margin: 15px 0;"></div>`;
  const damageResultDiv = html`<div></div>`;
  const damageButton = html`<button class="btn btn-danger w-100 btn-lg mt-2">üé≤ Roll Damage</button>`;
  
  // Render initial plot
  const damageParsed = parseDiceNotation(spell.damage, characterStats);
  if (damageParsed) {
    const dist = calculateDistribution(damageParsed.diceTerms, damageParsed.constantBonus);
    const data = Array.from(dist).map(([outcome, prob]) => ({outcome, probability: prob})).sort((a, b) => a.outcome - b.outcomes);
    damagePlotDiv.appendChild(createPlot(data, null, 450));
  }
  
  damageButton.onclick = () => {
    const parsed = parseDiceNotation(spell.damage, characterStats);
    if (!parsed) {
      damageResultDiv.innerHTML = '<div class="alert alert-warning mt-2">Invalid formula!</div>';
      return;
    }
    
    const result = rollDice(parsed.diceTerms, parsed.constantBonus);
    const dist = calculateDistribution(parsed.diceTerms, parsed.constantBonus);
    const data = Array.from(dist).map(([outcome, prob]) => ({outcome, probability: prob})).sort((a, b) => a.outcome - b.outcome);
    
    const cumulativeProb = data.reduce((acc, d) => d.outcome < result ? acc + d.probability : acc, 0);
    const percentile = (cumulativeProb * 100).toFixed(0);
    
    damageResultDiv.innerHTML = '';
    damageResultDiv.appendChild(html`
      <div class="result-box p-3 mt-3 border rounded text-center" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white;">
        <div class="display-4 fw-bold">${result}</div>
        <div class="mt-2">
          <span class="badge bg-light text-dark fs-6">${percentile}th percentile</span>
        </div>
      </div>
    `);
    
    damagePlotDiv.innerHTML = '';
    damagePlotDiv.appendChild(createPlot(data, result, 450));
  };
  
  damageSection.appendChild(html`<div><label class="small text-muted fw-bold mb-1">Formula</label></div>`);
  damageSection.appendChild(damageInput);
  damageSection.appendChild(damageResolvedDisplay);
  damageSection.appendChild(damagePlotDiv);
  damageSection.appendChild(damageButton);
  damageSection.appendChild(damageResultDiv);
  
  flexContainer.appendChild(damageSection);
  
  container.appendChild(html`
    <style>
      .result-box {
        animation: slideIn 0.4s ease-out;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      }
      @keyframes slideIn {
        from { 
          opacity: 0; 
          transform: translateY(-20px) scale(0.95); 
        }
        to { 
          opacity: 1; 
          transform: translateY(0) scale(1); 
        }
      }
      .small strong {
        font-family: 'Courier New', monospace;
        color: #495057;
        font-size: 0.95em;
      }
    </style>
  `);
  container.appendChild(card);
  
  return container;
}
```

```{ojs}
//| echo: false
spellCard
```
