[
  {
    "objectID": "page1.html",
    "href": "page1.html",
    "title": "Page 1",
    "section": "",
    "text": "This is page 1 baby",
    "crumbs": [
      "Home",
      "Page 1"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home",
    "section": "",
    "text": "Welcome to the website of THE Hunter Kruger-Ilingworth\nSee to the left some tools that I made",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "diceroll.html",
    "href": "diceroll.html",
    "title": "Dice Roll Utility",
    "section": "",
    "text": "Plot = import(\"https://esm.sh/@observablehq/plot@0.6\")\nd3 = import(\"https://esm.sh/d3@7\")",
    "crumbs": [
      "Tools",
      "Dice Roll Utility"
    ]
  },
  {
    "objectID": "diceroll.html#roll-results",
    "href": "diceroll.html#roll-results",
    "title": "Dice Roll Utility",
    "section": "üé≤ Roll Results",
    "text": "üé≤ Roll Results\n\nrollResults = {\n  const state = rollTrigger;\n  \n  if (!state || !state.spell) {\n    return html`\n      &lt;div class=\"alert alert-info\"&gt;\n        &lt;strong&gt;Click a üé≤ Roll button above&lt;/strong&gt; to see your result and probability distribution!\n      &lt;/div&gt;\n    `;\n  }\n  \n  // Convert distribution to array\n  const data = Array.from(state.distribution)\n    .map(([outcome, prob]) =&gt; ({outcome, probability: prob}))\n    .sort((a, b) =&gt; a.outcome - b.outcome);\n  \n  // Calculate percentile\n  const cumulativeProb = data.reduce((acc, d) =&gt; {\n    if (d.outcome &lt; state.result) {\n      return acc + d.probability;\n    }\n    return acc;\n  }, 0);\n  const percentile = (cumulativeProb * 100).toFixed(1);\n  \n  // Calculate stats\n  const outcomes = data.map(d =&gt; d.outcome);\n  const probs = data.map(d =&gt; d.probability);\n  const mean = data.reduce((sum, d) =&gt; sum + d.outcome * d.probability, 0);\n  const variance = data.reduce((sum, d) =&gt; sum + Math.pow(d.outcome - mean, 2) * d.probability, 0);\n  const stdDev = Math.sqrt(variance);\n  const min = Math.min(...outcomes);\n  const max = Math.max(...outcomes);\n  \n  return html`\n    &lt;div class=\"card shadow mb-3\"&gt;\n      &lt;div class=\"card-header bg-primary text-white\"&gt;\n        &lt;h5 class=\"mb-0\"&gt;\n          &lt;strong&gt;${state.spell}&lt;/strong&gt; ‚Äî ${state.type}\n        &lt;/h5&gt;\n      &lt;/div&gt;\n      &lt;div class=\"card-body\"&gt;\n        &lt;div class=\"row mb-3\"&gt;\n          &lt;div class=\"col-12 text-center\"&gt;\n            &lt;div class=\"result-display\"&gt;\n              &lt;div class=\"display-3 fw-bold text-primary mb-2\"&gt;${state.result}&lt;/div&gt;\n              &lt;div class=\"text-muted mb-2\"&gt;\n                &lt;code&gt;${state.formula}&lt;/code&gt; ‚Üí &lt;code&gt;${state.resolved}&lt;/code&gt;\n              &lt;/div&gt;\n              &lt;div&gt;\n                &lt;span class=\"badge bg-info fs-6\"&gt;Percentile: ${percentile}%&lt;/span&gt;\n                &lt;span class=\"badge bg-secondary fs-6 ms-2\"&gt;\n                  ${percentile &lt; 25 ? 'üòû Below Average' : \n                    percentile &lt; 50 ? 'üòê Below Average' : \n                    percentile &lt; 75 ? 'üòä Above Average' : \n                    'üéâ Great Roll!'}\n                &lt;/span&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n        \n        &lt;div class=\"row mb-3\"&gt;\n          &lt;div class=\"col-12\"&gt;\n            &lt;h6 class=\"text-muted mb-2\"&gt;Probability Distribution&lt;/h6&gt;\n            ${Plot.plot({\n              width: Math.min(800, window.innerWidth - 100),\n              height: 350,\n              marginBottom: 50,\n              marginLeft: 50,\n              x: { \n                label: \"Roll Outcome ‚Üí\",\n                grid: true\n              },\n              y: { \n                label: \"‚Üë Probability\",\n                percent: true,\n                grid: true\n              },\n              marks: [\n                Plot.barY(data, {\n                  x: \"outcome\",\n                  y: \"probability\",\n                  fill: d =&gt; d.outcome === state.result ? \"#dc3545\" : \"#6c757d\",\n                  opacity: d =&gt; d.outcome === state.result ? 1 : 0.5,\n                  tip: true\n                }),\n                Plot.ruleX([state.result], {\n                  stroke: \"#dc3545\",\n                  strokeWidth: 3,\n                  strokeDasharray: \"4 4\"\n                }),\n                Plot.text([{x: state.result, y: Math.max(...probs) * 1.1}], {\n                  x: \"x\",\n                  y: \"y\",\n                  text: [\"Your Roll\"],\n                  fill: \"#dc3545\",\n                  fontWeight: \"bold\",\n                  fontSize: 12\n                })\n              ]\n            })}\n          &lt;/div&gt;\n        &lt;/div&gt;\n        \n        &lt;div class=\"row text-center\"&gt;\n          &lt;div class=\"col-3\"&gt;\n            &lt;div class=\"h5 mb-0 text-primary\"&gt;${min}&lt;/div&gt;\n            &lt;small class=\"text-muted\"&gt;Min&lt;/small&gt;\n          &lt;/div&gt;\n          &lt;div class=\"col-3\"&gt;\n            &lt;div class=\"h5 mb-0 text-primary\"&gt;${mean.toFixed(1)}&lt;/div&gt;\n            &lt;small class=\"text-muted\"&gt;Mean&lt;/small&gt;\n          &lt;/div&gt;\n          &lt;div class=\"col-3\"&gt;\n            &lt;div class=\"h5 mb-0 text-primary\"&gt;${max}&lt;/div&gt;\n            &lt;small class=\"text-muted\"&gt;Max&lt;/small&gt;\n          &lt;/div&gt;\n          &lt;div class=\"col-3\"&gt;\n            &lt;div class=\"h5 mb-0 text-primary\"&gt;${stdDev.toFixed(1)}&lt;/div&gt;\n            &lt;small class=\"text-muted\"&gt;Std Dev&lt;/small&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  `;\n}\n\n\n\n\n\n\n\nrollResults",
    "crumbs": [
      "Tools",
      "Dice Roll Utility"
    ]
  },
  {
    "objectID": "diceroll.html#character-stats",
    "href": "diceroll.html#character-stats",
    "title": "Dice Roll Utility",
    "section": "Character Stats",
    "text": "Character Stats\n\nstatsInputs = html`\n&lt;div class=\"row g-2\"&gt;\n  &lt;div class=\"col-md-4\"&gt;\n    ${Inputs.range([0, 6], {value: 3, step: 1, label: \"Proficiency Bonus\"})}\n  &lt;/div&gt;\n  &lt;div class=\"col-md-4\"&gt;\n    ${Inputs.range([-5, 10], {value: 1, step: 1, label: \"STR\"})}\n  &lt;/div&gt;\n  &lt;div class=\"col-md-4\"&gt;\n    ${Inputs.range([-5, 10], {value: 2, step: 1, label: \"DEX\"})}\n  &lt;/div&gt;\n  &lt;div class=\"col-md-4\"&gt;\n    ${Inputs.range([-5, 10], {value: 2, step: 1, label: \"CON\"})}\n  &lt;/div&gt;\n  &lt;div class=\"col-md-4\"&gt;\n    ${Inputs.range([-5, 10], {value: 0, step: 1, label: \"INT\"})}\n  &lt;/div&gt;\n  &lt;div class=\"col-md-4\"&gt;\n    ${Inputs.range([-5, 10], {value: 4, step: 1, label: \"WIS\"})}\n  &lt;/div&gt;\n  &lt;div class=\"col-md-4\"&gt;\n    ${Inputs.range([-5, 10], {value: -1, step: 1, label: \"CHA\"})}\n  &lt;/div&gt;\n&lt;/div&gt;\n`\n\nviewof PROFICIENCY_BONUS = Inputs.range([0, 6], {value: 3, step: 1, label: \"Proficiency Bonus\"})\nviewof STR_MOD = Inputs.range([-5, 10], {value: 1, step: 1, label: \"STR\"})\nviewof DEX_MOD = Inputs.range([-5, 10], {value: 2, step: 1, label: \"DEX\"})\nviewof CON_MOD = Inputs.range([-5, 10], {value: 2, step: 1, label: \"CON\"})\nviewof INT_MOD = Inputs.range([-5, 10], {value: 0, step: 1, label: \"INT\"})\nviewof WIS_MOD = Inputs.range([-5, 10], {value: 4, step: 1, label: \"WIS\"})\nviewof CHA_MOD = Inputs.range([-5, 10], {value: -1, step: 1, label: \"CHA\"})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Combine stats into object\ncharacterStats = ({\n  PROFICIENCY_BONUS,\n  STR_MOD,\n  DEX_MOD,\n  CON_MOD,\n  INT_MOD,\n  WIS_MOD,\n  CHA_MOD\n})\n\n\n\n\n\n\n\ninitialSpells = ({\n  Fireball: {\n    level: 3,\n    to_hit: \"1d20 + PROFICIENCY_BONUS + WIS_MOD\",\n    damage: \"8d6\"\n  },\n  \"Cure Wounds\": {\n    level: 1,\n    to_hit: \"None\",\n    damage: \"1d8 + WIS_MOD\"\n  },\n  Greataxe: {\n    level: 0,\n    to_hit: \"1d20 + PROFICIENCY_BONUS + STR_MOD\",\n    damage: \"1d12 + STR_MOD\"\n  }\n})\n\nviewof spellsConfigInput = Inputs.input(initialSpells)\nspellsConfig = spellsConfigInput\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote‚öôÔ∏è Import / Export Config\n\n\n\n\n\n\nautoGeneratedConfig = JSON.stringify({\n  character_info: characterStats,\n  spells: spellsConfig\n}, null, 2)\n\nhtml`&lt;textarea rows=\"12\" style=\"width: 100%; font-family: monospace; padding: 10px; font-size: 0.85em;\"&gt;${autoGeneratedConfig}&lt;/textarea&gt;`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction parseDiceNotation(notation, stats) {\n  if (!notation || notation === \"None\") return null;\n  \n  let formula = notation.trim();\n  Object.keys(stats).forEach(key =&gt; {\n    const regex = new RegExp(key, 'g');\n    formula = formula.replace(regex, stats[key]);\n  });\n  \n  const parts = formula.split(/([+-])/);\n  let diceTerms = [];\n  let constantBonus = 0;\n  \n  let currentSign = 1;\n  for (let part of parts) {\n    part = part.trim();\n    if (part === '+') {\n      currentSign = 1;\n    } else if (part === '-') {\n      currentSign = -1;\n    } else if (part.includes('d')) {\n      const [count, sides] = part.split('d').map(x =&gt; parseInt(x));\n      if (!isNaN(count) && !isNaN(sides)) {\n        diceTerms.push({ count, sides, sign: currentSign });\n      }\n    } else if (part && !isNaN(part)) {\n      constantBonus += currentSign * parseInt(part);\n    }\n  }\n  \n  return { diceTerms, constantBonus, original: notation, resolved: formula };\n}\n\nfunction calculateDistribution(diceTerms, constantBonus) {\n  if (diceTerms.length === 0) {\n    return new Map([[constantBonus, 1.0]]);\n  }\n  \n  let distribution = singleDieDistribution(diceTerms[0].count, diceTerms[0].sides, diceTerms[0].sign);\n  \n  for (let i = 1; i &lt; diceTerms.length; i++) {\n    const nextDist = singleDieDistribution(diceTerms[i].count, diceTerms[i].sides, diceTerms[i].sign);\n    distribution = convolve(distribution, nextDist);\n  }\n  \n  if (constantBonus !== 0) {\n    const shifted = new Map();\n    for (let [outcome, prob] of distribution) {\n      shifted.set(outcome + constantBonus, prob);\n    }\n    distribution = shifted;\n  }\n  \n  return distribution;\n}\n\nfunction singleDieDistribution(count, sides, sign = 1) {\n  if (count === 0) return new Map([[0, 1.0]]);\n  \n  let dist = new Map();\n  for (let i = 1; i &lt;= sides; i++) {\n    dist.set(sign * i, 1.0 / sides);\n  }\n  \n  for (let n = 1; n &lt; count; n++) {\n    const oneDie = new Map();\n    for (let i = 1; i &lt;= sides; i++) {\n      oneDie.set(sign * i, 1.0 / sides);\n    }\n    dist = convolve(dist, oneDie);\n  }\n  \n  return dist;\n}\n\nfunction convolve(dist1, dist2) {\n  const result = new Map();\n  \n  for (let [outcome1, prob1] of dist1) {\n    for (let [outcome2, prob2] of dist2) {\n      const sum = outcome1 + outcome2;\n      const prob = prob1 * prob2;\n      result.set(sum, (result.get(sum) || 0) + prob);\n    }\n  }\n  \n  return result;\n}\n\nfunction rollDice(diceTerms, constantBonus) {\n  let total = constantBonus;\n  \n  for (let term of diceTerms) {\n    for (let i = 0; i &lt; term.count; i++) {\n      const roll = Math.floor(Math.random() * term.sides) + 1;\n      total += term.sign * roll;\n    }\n  }\n  \n  return total;\n}\n\nfunction createPlot(data, rollResult) {\n  const outcomes = data.map(d =&gt; d.outcome);\n  const probs = data.map(d =&gt; d.probability);\n  \n  return Plot.plot({\n    width: 400,\n    height: 200,\n    marginBottom: 40,\n    marginLeft: 40,\n    marginRight: 20,\n    x: { \n      label: \"Outcome\",\n      labelAnchor: \"center\"\n    },\n    y: { \n      label: \"Probability\",\n      percent: true,\n      labelAnchor: \"center\"\n    },\n    marks: [\n      Plot.barY(data, {\n        x: \"outcome\",\n        y: \"probability\",\n        fill: d =&gt; d.outcome === rollResult ? \"#dc3545\" : \"#6c757d\",\n        opacity: d =&gt; d.outcome === rollResult ? 1 : 0.5\n      }),\n      Plot.ruleX([rollResult], {\n        stroke: \"#dc3545\",\n        strokeWidth: 2\n      })\n    ]\n  });\n}",
    "crumbs": [
      "Tools",
      "Dice Roll Utility"
    ]
  },
  {
    "objectID": "diceroll.html#addedit-spells",
    "href": "diceroll.html#addedit-spells",
    "title": "Dice Roll Utility",
    "section": "Add/Edit Spells",
    "text": "Add/Edit Spells\n\ninitialSpells = ({\n  Fireball: {\n    level: 3,\n    to_hit: \"1d20 + PROFICIENCY_BONUS + WIS_MOD\",\n    damage: \"8d6\"\n  },\n  \"Cure Wounds\": {\n    level: 1,\n    to_hit: \"None\",\n    damage: \"1d8 + WIS_MOD\"\n  },\n  Greataxe: {\n    level: 0,\n    to_hit: \"1d20 + PROFICIENCY_BONUS + STR_MOD\",\n    damage: \"1d12 + STR_MOD\"\n  }\n})\n\n// Mutable spells config\nviewof spellsConfigInput = Inputs.input(initialSpells)\nspellsConfig = spellsConfigInput\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction parseDiceNotation(notation, stats) {\n  if (!notation || notation === \"None\") return null;\n  \n  // First substitute all stat modifiers\n  let formula = notation.trim();\n  Object.keys(stats).forEach(key =&gt; {\n    const regex = new RegExp(key, 'g');\n    formula = formula.replace(regex, stats[key]);\n  });\n  \n  // Parse the formula: \"1d20 + 3 + 4\" or \"8d6\" etc.\n  const parts = formula.split(/([+-])/);\n  let diceTerms = [];\n  let constantBonus = 0;\n  \n  let currentSign = 1;\n  for (let part of parts) {\n    part = part.trim();\n    if (part === '+') {\n      currentSign = 1;\n    } else if (part === '-') {\n      currentSign = -1;\n    } else if (part.includes('d')) {\n      const [count, sides] = part.split('d').map(x =&gt; parseInt(x));\n      if (!isNaN(count) && !isNaN(sides)) {\n        diceTerms.push({ count, sides, sign: currentSign });\n      }\n    } else if (part && !isNaN(part)) {\n      constantBonus += currentSign * parseInt(part);\n    }\n  }\n  \n  return { diceTerms, constantBonus, original: notation, resolved: formula };\n}\n\n// Calculate probability distribution using convolution\nfunction calculateDistribution(diceTerms, constantBonus) {\n  if (diceTerms.length === 0) {\n    return new Map([[constantBonus, 1.0]]);\n  }\n  \n  let distribution = singleDieDistribution(diceTerms[0].count, diceTerms[0].sides, diceTerms[0].sign);\n  \n  for (let i = 1; i &lt; diceTerms.length; i++) {\n    const nextDist = singleDieDistribution(diceTerms[i].count, diceTerms[i].sides, diceTerms[i].sign);\n    distribution = convolve(distribution, nextDist);\n  }\n  \n  if (constantBonus !== 0) {\n    const shifted = new Map();\n    for (let [outcome, prob] of distribution) {\n      shifted.set(outcome + constantBonus, prob);\n    }\n    distribution = shifted;\n  }\n  \n  return distribution;\n}\n\nfunction singleDieDistribution(count, sides, sign = 1) {\n  if (count === 0) return new Map([[0, 1.0]]);\n  \n  let dist = new Map();\n  for (let i = 1; i &lt;= sides; i++) {\n    dist.set(sign * i, 1.0 / sides);\n  }\n  \n  for (let n = 1; n &lt; count; n++) {\n    const oneDie = new Map();\n    for (let i = 1; i &lt;= sides; i++) {\n      oneDie.set(sign * i, 1.0 / sides);\n    }\n    dist = convolve(dist, oneDie);\n  }\n  \n  return dist;\n}\n\nfunction convolve(dist1, dist2) {\n  const result = new Map();\n  \n  for (let [outcome1, prob1] of dist1) {\n    for (let [outcome2, prob2] of dist2) {\n      const sum = outcome1 + outcome2;\n      const prob = prob1 * prob2;\n      result.set(sum, (result.get(sum) || 0) + prob);\n    }\n  }\n  \n  return result;\n}\n\nfunction rollDice(diceTerms, constantBonus) {\n  let total = constantBonus;\n  \n  for (let term of diceTerms) {\n    for (let i = 0; i &lt; term.count; i++) {\n      const roll = Math.floor(Math.random() * term.sides) + 1;\n      total += term.sign * roll;\n    }\n  }\n  \n  return total;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// State for active roll\nviewof rollTrigger = Inputs.input({spell: null, type: null, result: null, distribution: null, formula: null, resolved: null, timestamp: 0})\n\n\n\n\n\n\n\n// Create editable spell cards\nspellEditor = {\n  const spellEntries = Object.entries(spellsConfig);\n  \n  const cards = spellEntries.map(([name, spell], index) =&gt; {\n    // Create containers for inputs\n    const toHitContainer = html`&lt;div&gt;&lt;/div&gt;`;\n    const damageContainer = html`&lt;div&gt;&lt;/div&gt;`;\n    \n    // Create editable inputs\n    const toHitInput = Inputs.text({\n      value: spell.to_hit,\n      placeholder: \"e.g., 1d20 + PROFICIENCY_BONUS + STR_MOD\",\n      width: \"100%\"\n    });\n    \n    const damageInput = Inputs.text({\n      value: spell.damage,\n      placeholder: \"e.g., 2d6 + STR_MOD\",\n      width: \"100%\"\n    });\n    \n    // Update config when inputs change\n    toHitInput.addEventListener('input', (e) =&gt; {\n      const newSpells = {...spellsConfig};\n      newSpells[name].to_hit = e.target.value;\n      spellsConfigInput.value = newSpells;\n      spellsConfigInput.dispatchEvent(new Event(\"input\", {bubbles: true}));\n    });\n    \n    damageInput.addEventListener('input', (e) =&gt; {\n      const newSpells = {...spellsConfig};\n      newSpells[name].damage = e.target.value;\n      spellsConfigInput.value = newSpells;\n      spellsConfigInput.dispatchEvent(new Event(\"input\", {bubbles: true}));\n    });\n    \n    toHitContainer.appendChild(toHitInput);\n    damageContainer.appendChild(damageInput);\n    \n    // Create roll buttons\n    const makeRollButton = (rollType, formula, buttonClass) =&gt; {\n      const button = html`&lt;button class=\"btn ${buttonClass} btn-sm w-100 mt-2\"&gt;üé≤ Roll ${rollType}&lt;/button&gt;`;\n      \n      button.onclick = () =&gt; {\n        const parsed = parseDiceNotation(formula, characterStats);\n        if (!parsed) {\n          alert(\"Invalid dice formula!\");\n          return;\n        }\n        \n        const result = rollDice(parsed.diceTerms, parsed.constantBonus);\n        const dist = calculateDistribution(parsed.diceTerms, parsed.constantBonus);\n        \n        rollTrigger.value = {\n          spell: name,\n          type: rollType,\n          result,\n          distribution: dist,\n          formula: parsed.original,\n          resolved: parsed.resolved,\n          timestamp: Date.now()\n        };\n        rollTrigger.dispatchEvent(new Event(\"input\", {bubbles: true}));\n      };\n      \n      return button;\n    };\n    \n    return html`\n      &lt;div class=\"col-md-6 col-xl-4 mb-3\"&gt;\n        &lt;div class=\"card h-100 shadow-sm spell-card\"&gt;\n          &lt;div class=\"card-header d-flex justify-content-between align-items-center bg-light\"&gt;\n            &lt;strong&gt;${name}&lt;/strong&gt;\n            &lt;span class=\"badge bg-primary\"&gt;Lvl ${spell.level}&lt;/span&gt;\n          &lt;/div&gt;\n          &lt;div class=\"card-body\"&gt;\n            ${spell.to_hit !== \"None\" ? html`\n              &lt;div class=\"mb-3\"&gt;\n                &lt;label class=\"small text-muted fw-bold\"&gt;TO HIT&lt;/label&gt;\n                ${toHitContainer}\n                ${makeRollButton('To Hit', spell.to_hit, 'btn-outline-primary')}\n              &lt;/div&gt;\n            ` : ''}\n            \n            &lt;div&gt;\n              &lt;label class=\"small text-muted fw-bold\"&gt;DAMAGE&lt;/label&gt;\n              ${damageContainer}\n              ${makeRollButton('Damage', spell.damage, 'btn-outline-danger')}\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    `;\n  });\n  \n  return html`\n&lt;style&gt;\n  .spell-card {\n    transition: all 0.2s;\n  }\n  .spell-card:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 4px 12px rgba(0,0,0,0.15) !important;\n  }\n  .result-display {\n    animation: popIn 0.3s ease-out;\n  }\n  @keyframes popIn {\n    0% { transform: scale(0.8); opacity: 0; }\n    100% { transform: scale(1); opacity: 1; }\n  }\n&lt;/style&gt;\n\n&lt;div class=\"row\"&gt;\n  ${cards}\n&lt;/div&gt;\n`;\n}\n\n\n\n\n\n\n\nspellEditor",
    "crumbs": [
      "Tools",
      "Dice Roll Utility"
    ]
  },
  {
    "objectID": "diceroll.html#spells-actions",
    "href": "diceroll.html#spells-actions",
    "title": "Dice Roll Utility",
    "section": "Spells & Actions",
    "text": "Spells & Actions\n\nspellCards = {\n  const spellEntries = Object.entries(spellsConfig);\n  \n  const cards = spellEntries.map(([name, spell]) =&gt; {\n    const cardId = name.replace(/\\s+/g, '-');\n    \n    // Create containers\n    const card = html`&lt;div class=\"col-lg-6 mb-4\"&gt;&lt;/div&gt;`;\n    \n    const toHitInput = Inputs.text({\n      value: spell.to_hit,\n      placeholder: \"e.g., 1d20 + PROFICIENCY_BONUS + STR_MOD\"\n    });\n    \n    const damageInput = Inputs.text({\n      value: spell.damage,\n      placeholder: \"e.g., 2d6 + STR_MOD\"\n    });\n    \n    // Update config on input change\n    toHitInput.addEventListener('input', (e) =&gt; {\n      const newSpells = {...spellsConfig};\n      newSpells[name].to_hit = e.target.value;\n      spellsConfigInput.value = newSpells;\n      spellsConfigInput.dispatchEvent(new Event(\"input\", {bubbles: true}));\n    });\n    \n    damageInput.addEventListener('input', (e) =&gt; {\n      const newSpells = {...spellsConfig};\n      newSpells[name].damage = e.target.value;\n      spellsConfigInput.value = newSpells;\n      spellsConfigInput.dispatchEvent(new Event(\"input\", {bubbles: true}));\n    });\n    \n    // Result containers\n    const toHitResultDiv = html`&lt;div class=\"mt-2\"&gt;&lt;/div&gt;`;\n    const damageResultDiv = html`&lt;div class=\"mt-2\"&gt;&lt;/div&gt;`;\n    \n    // Roll buttons\n    const toHitButton = html`&lt;button class=\"btn btn-primary btn-sm mt-2 w-100\"&gt;üé≤ Roll To Hit&lt;/button&gt;`;\n    const damageButton = html`&lt;button class=\"btn btn-danger btn-sm mt-2 w-100\"&gt;üé≤ Roll Damage&lt;/button&gt;`;\n    \n    toHitButton.onclick = () =&gt; {\n      const parsed = parseDiceNotation(spell.to_hit, characterStats);\n      if (!parsed) {\n        toHitResultDiv.innerHTML = '&lt;div class=\"alert alert-warning p-2\"&gt;Invalid formula!&lt;/div&gt;';\n        return;\n      }\n      \n      const result = rollDice(parsed.diceTerms, parsed.constantBonus);\n      const dist = calculateDistribution(parsed.diceTerms, parsed.constantBonus);\n      const data = Array.from(dist).map(([outcome, prob]) =&gt; ({outcome, probability: prob})).sort((a, b) =&gt; a.outcome - b.outcome);\n      \n      const cumulativeProb = data.reduce((acc, d) =&gt; d.outcome &lt; result ? acc + d.probability : acc, 0);\n      const percentile = (cumulativeProb * 100).toFixed(0);\n      \n      toHitResultDiv.innerHTML = '';\n      toHitResultDiv.appendChild(html`\n        &lt;div class=\"result-box p-2 mt-2 border rounded bg-light\"&gt;\n          &lt;div class=\"text-center mb-2\"&gt;\n            &lt;span class=\"fs-3 fw-bold text-primary\"&gt;${result}&lt;/span&gt;\n            &lt;span class=\"ms-2 badge bg-info\"&gt;${percentile}%ile&lt;/span&gt;\n          &lt;/div&gt;\n          &lt;div class=\"plot-container\"&gt;\n            ${createPlot(data, result)}\n          &lt;/div&gt;\n        &lt;/div&gt;\n      `);\n    };\n    \n    damageButton.onclick = () =&gt; {\n      const parsed = parseDiceNotation(spell.damage, characterStats);\n      if (!parsed) {\n        damageResultDiv.innerHTML = '&lt;div class=\"alert alert-warning p-2\"&gt;Invalid formula!&lt;/div&gt;';\n        return;\n      }\n      \n      const result = rollDice(parsed.diceTerms, parsed.constantBonus);\n      const dist = calculateDistribution(parsed.diceTerms, parsed.constantBonus);\n      const data = Array.from(dist).map(([outcome, prob]) =&gt; ({outcome, probability: prob})).sort((a, b) =&gt; a.outcome - b.outcome);\n      \n      const cumulativeProb = data.reduce((acc, d) =&gt; d.outcome &lt; result ? acc + d.probability : acc, 0);\n      const percentile = (cumulativeProb * 100).toFixed(0);\n      \n      damageResultDiv.innerHTML = '';\n      damageResultDiv.appendChild(html`\n        &lt;div class=\"result-box p-2 mt-2 border rounded bg-light\"&gt;\n          &lt;div class=\"text-center mb-2\"&gt;\n            &lt;span class=\"fs-3 fw-bold text-danger\"&gt;${result}&lt;/span&gt;\n            &lt;span class=\"ms-2 badge bg-info\"&gt;${percentile}%ile&lt;/span&gt;\n          &lt;/div&gt;\n          &lt;div class=\"plot-container\"&gt;\n            ${createPlot(data, result)}\n          &lt;/div&gt;\n        &lt;/div&gt;\n      `);\n    };\n    \n    // Build card\n    const toHitSection = spell.to_hit !== \"None\" ? html`\n      &lt;div class=\"mb-3 pb-3 border-bottom\"&gt;\n        &lt;label class=\"small text-muted fw-bold mb-1\"&gt;TO HIT&lt;/label&gt;\n        ${toHitInput}\n        ${toHitButton}\n        ${toHitResultDiv}\n      &lt;/div&gt;\n    ` : '';\n    \n    card.appendChild(html`\n      &lt;div class=\"card shadow-sm h-100\"&gt;\n        &lt;div class=\"card-header d-flex justify-content-between align-items-center\"&gt;\n          &lt;strong&gt;${name}&lt;/strong&gt;\n          &lt;span class=\"badge bg-primary\"&gt;Lvl ${spell.level}&lt;/span&gt;\n        &lt;/div&gt;\n        &lt;div class=\"card-body\"&gt;\n          ${toHitSection}\n          &lt;div&gt;\n            &lt;label class=\"small text-muted fw-bold mb-1\"&gt;DAMAGE&lt;/label&gt;\n            ${damageInput}\n            ${damageButton}\n            ${damageResultDiv}\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    `);\n    \n    return card;\n  });\n  \n  return html`\n&lt;style&gt;\n  .card { transition: all 0.2s; }\n  .card:hover { box-shadow: 0 4px 12px rgba(0,0,0,0.15) !important; }\n  .result-box {\n    animation: slideIn 0.3s ease-out;\n    background: linear-gradient(to bottom, #f8f9fa, #ffffff) !important;\n  }\n  @keyframes slideIn {\n    from { opacity: 0; transform: translateY(-10px); }\n    to { opacity: 1; transform: translateY(0); }\n  }\n  .plot-container { \n    display: flex; \n    justify-content: center; \n  }\n&lt;/style&gt;\n\n&lt;div class=\"row\"&gt;\n  ${cards}\n&lt;/div&gt;\n`;\n}\n\n\n\n\n\n\n\nspellCards",
    "crumbs": [
      "Tools",
      "Dice Roll Utility"
    ]
  }
]